New year, same me
---

Watch me code in Haskell for 25 days straight

| Day 	| Part 1 	| Part 2 	| Day 	| Part 1 	| Part 2 	| Day 	| Part 1 	| Part 2 	|
|-----	|--------	|--------	|-----	|--------	|--------	|-----	|--------	|--------	|
|  01 	|    ✅   	|    ✅   	|  10 	|        	|        	|  19 	|        	|        	|
|  02 	|    ✅   	|    ✅   	|  11 	|        	|        	|  20 	|        	|        	|
|  03 	|    ✅   	|    ✅   	|  12 	|        	|        	|  21 	|        	|        	|
|  04 	|    ✅   	|    ✅   	|  13 	|        	|        	|  22 	|        	|        	|
|  05 	|    ✅   	|    ✅   	|  14 	|        	|        	|  23 	|        	|        	|
|  06 	|    ✅   	|    ✅   	|  15 	|        	|        	|  24 	|        	|        	|
|  07 	|    ✅   	|    ✅   	|  16 	|        	|        	|  25 	|        	|        	|
|  08 	|        	|        	|  17 	|        	|        	|     	|        	|        	|
|  09 	|        	|        	|  18 	|        	|        	|     	|        	|        	|

---

## Personnal Feedback

### Day 1:
Nothing quite remarkable, I wasn't going to use splitOn at first but I decided
it was cleaner to use it (I am not sure it is standard though.)

### Day 2:
Because this is really simple to solve, I tried to do it in the most cumbersome
and compact way possible. Basically, the idea is to put everything in a matrix
and notice that there is a cycle to the possible scores.

### Day 3:
Weirdly enough, I really liked this one. I am quite proud of my solution :D

### Day 4:
It is way too early for me to be awake, my solution is quite silly but it works.

### Day 5:
The hardest part about this one was the parsing, and even that wasn't too hard

### Day 6:
Easiest one.

### Day 7:
This one was a bit harder, but once the parsing is done then it's not that hard.
Is it weird that part 2 was easier than part 1 for me ?
Anyway, tree traversals go brrrrrr (although I'd hoped to make my code clean
which isn't the case right now :,()
